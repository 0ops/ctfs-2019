import random

def primorial(p):
    q = 1
    s = 1
    while q < p:
        r = next_prime(q)
        if r <= p:
            s *= r
            q = r
        else:
            break
    return s

# only two cases for a and b to generate 512 bit
# a, b = 359, 7 # not this case
a, b = 379, 29

# n%(prod(prime_range(32, 67))) == 1574000 == 1574 * 1000
r = 1574
# r = 1000

n = 129267954332200676615739227295907855158658739979210900708976549380609989409956408435684374935748935918839455337906315852534764123844258593239440161506513191263699117749750762173637210021984649302676930074737438675523494086114284695245002078910492689149197954131695708624630827382893369282116803593958219295071
pd = prod(prime_range(b+1, a+1))
PR.<x> = PolynomialRing(Zmod(n))
f = x*pd - r
res = f.monic().small_roots(X=2^36, beta=0.3)
print res
s = res[0]
p = Integer(s*pd-r)
assert n%p==0
q = n//p
phi = (p-1)*(q-1)
d = inverse_mod(65537, phi)
enc = 123828011786345664757585942310038992331055176660679165398920365204623335291878173959876308977115607518900415801962848580747200997185606420410437572095447682798017319498742987210291931673054112968527192210375048958877146513037193636705010232608708929769672565897606711155251354598146987357344810260248226805138
flag = pow(enc,d,n)
from Crypto.Util.number import long_to_bytes
print long_to_bytes(flag)

