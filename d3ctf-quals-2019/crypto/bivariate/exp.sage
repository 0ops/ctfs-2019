from sage.all import *
from itertools import product

F = PolynomialRing(ZZ, names='x,y,z')
x, y, z = F.gens()

debug = 0

if debug:
    N = 15801398095963153678740257537746418701500792734178255086538988857817106754452589755835647443452104396692798928727071680992285314393939534885717915874210959848718533383313693279947141622183276991677603939221182108592506041805765335654661793454672824059845192463740874029305950722341680735523114608485594790376365594444405671652646619685479883098584221444583448535212382168818524428815346460366879451873055929024433851240812240959876065842924222612424262800791108519617515046715466105002478169084268735491016551184923375499976765782157870595340924272289389839134808828335878955050926701063932066938107531939127263868127
    p = 160826562449992609272632870762290834237857582852648245062316483163912625311131169356289585444328934329929021578684439555375696615773482106874136783307738147770088853586848048037418220268385666849314488080433958217561976027616347989446909110212067718570438233519594099635437479168287132377600107037520253381937
    p0 = 0xe8229e3cbf86e0b9f423edd90ddd0038754719c216040f328d6c8db1584fc0ee4c7cb83d53b22b847954387d759b2cedc3dd27a2d7e96356799b91f549e339797bebc0adbeea4218207036928dfd3c8b04c76c7e3eb8881e0937599fad1c066edc773f84357a600000000000000000000000000
    solx = 0xe5064df65ca95227dfd0638fa
    soly = 0x3007232cedc8dcd9304576d31
    solz = 98251171045681203182111272873122352905626669194241678334261367264962902400429009012068291134978449944742992482516319121732912547592701957435375533710086310557720059832564423639735420201314620395483105434144060769746464841434320420992799324356948086673379049345571374966386359645255985581413205850668176473871
    X = solx + 100
    Y = soly + 100
    Z = solz + 100
else:
    N = 29645777419353736043057269010272359991416746014481631913846394670078485669726163429148261773650808178885540922407769261977694870685655675641674238423494302502713669170229824386613320560323567408297922627498904721032641809270387608763375110868803588215842220559925272939588535929617335141314939188135485819647392547941664721198106918867256215010691258972314587355422307935800963252186373953902703756486263607531802422220243261067840601049386548437700448106992244972092205487949271972315893678254707578275422023764563404729727966134925789323455747715178318199560676511490769844114918905097088133071853897724375466871753
    p0 = 19994706539344817615577001340218084154374248082066669466133143688464179834710257290336770530283220217475114036198814696889289562075455713159534426021509764445583402971591173189115806435513627099657084735309947492280373743846773519959600992501216048618966605151951399747378479104
    X = 1 << 100
    Y = 1 << 100
    Z = 1 << 1024

f = (x * (1<<924) + p0 + y) * z

# polynomial is fine?
if debug:
    assert 0 == f.subs(x=solx, y=soly, z=solz) % N
    assert 0 != f.subs(x=solx+1, y=soly, z=solz) % N
    assert 0 != f.subs(x=solx, y=soly+1, z=solz) % N
assert 0 != f.subs(x=123, y=31337, z=1337)

# [!] configurable parameters, by hand...
mm = 4
tt = 1

# generate polynomials for lattice
polys = []

for kk in range(mm+1):
    for ii in range(mm+1-kk):
        for jj in range(mm+1-kk-ii):
            poly = x^ii * z^jj * f^kk * N^(mm-kk)
            polys.append(poly)

for kk in range(mm+1):
    for ii in range(mm+1-kk):
        for jj in range(mm+1-kk-ii):
            poly = x^ii * y^jj * f^kk * N^(mm-kk)
            polys.append(poly)

for jj in range(1, tt+1):
    for kk in range(floor(mm/tt)*jj, mm+1):
        for ll in range(kk+1):
            poly = y^jj * z^(kk-ll) * f^ll * N^(mm-ll)
            polys.append(poly)

polys = sorted(polys)
monomials = []
for poly in polys:
    monomials += poly.monomials()
monomials = sorted(set(monomials))
# print '[+]list of monomials:', monomials
print len(monomials), len(polys)
# assert len(monomials) == len(polys)
dim1 = len(polys)
dim2 = len(monomials)
M = matrix(ZZ, dim1, dim2)
for ii in xrange(dim1):
    M[ii, 0] = polys[ii](0, 0, 0)
    for jj in xrange(dim2):
        if monomials[jj] in polys[ii].monomials():
            M[ii, jj] = polys[ii].monomial_coefficient(monomials[jj]) * monomials[jj](X, Y, Z)
print ''
print '=' * 128
print ''

B = M.LLL()

PS.<xs, ys> = PolynomialRing(QQ)
hs = []
for ii in range(dim1):
    pol = 0
    for jj in range(dim2):
        pol += monomials[jj](xs, ys, 1) * B[ii, jj] / monomials[jj](X, Y, Z)
    # assert pol(xs=solx, ys=soly) % N == 0
    # if pol != 0 and pol(xs=solx, ys=soly) == 0:
    if pol != 0 and len(hs) < 5:
        print "Got poly with good root over ZZ. (Vector %d)" % ii
        hs.append(pol)

for i in hs:
    print i.monomials()
pset = PS.ideal(hs)
# assert pset.dimension() == 0
print pset.dimension()
print "[+]Well done! It's solvable!"
proot = pset.variety()[0]
print "[+]Got root:", proot
if debug:
    print solx, soly
    print p
p = (proot[xs] * (1<<924) + p0 + proot[ys])
q = N / p
assert p*q == N

c = 7694028696447203055167399614781742755233053501626948191487643786599831140635293828884780055356284626663129451347502647051088048380199347483536968808813587826859620049775396873717297332186322514747353165132000670895060078379130985428951115709881435036017128132729124851968540263457421976158921742081845963927952802266087877892966035363073622017314606731162063764705983433839542946381332691603550403398970180516625310081042782432877464770353770090161091698648807139629607359568734465463219577161798805093345331883850704725036104900961175566402889261422944217295065701981664028001963430622802457144426613143149027199687
d = inverse_mod(65537, (p-1)*(q-1))
print hex(pow(c,d,N).lift()).decode("hex")